//! Kotlin DSL configuration loader
//! 
//! This module loads configuration data generated by the Kotlin DSL compiler
//! and converts it into the graph desktop configuration format.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use anyhow::{Result, Context};

/// Kotlin DSL compiled configuration root
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct KotlinDslConfig {
    /// System configuration
    pub system: Option<SystemConfig>,
    /// Graph desktop configuration
    pub graph_desktop: Option<GraphDesktopDslConfig>,
    /// Services configuration
    pub services: Option<ServicesConfig>,
    /// Package groups
    pub packages: Option<PackagesConfig>,
}

/// System configuration from Kotlin DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SystemConfig {
    pub hostname: String,
    pub timezone: String,
    pub locale: String,
}

/// Graph desktop configuration from Kotlin DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphDesktopDslConfig {
    pub enabled: bool,
    pub rendering_engine: String,
    pub enable_physics: bool,
    pub enable_gestures: bool,
    pub enable_keyboard_navigation: bool,
    pub enable_voice_control: bool,
    pub max_nodes: u32,
    pub max_edges: u32,
    pub performance_mode: String,
    
    /// Node type definitions
    pub node_types: HashMap<String, NodeTypeDef>,
    /// Edge type definitions
    pub edge_types: HashMap<String, EdgeTypeDef>,
    /// Layout configurations
    pub layouts: HashMap<String, LayoutConfig>,
    /// Interaction configurations
    pub interactions: HashMap<String, InteractionDef>,
    /// Visual effects
    pub visual_effects: HashMap<String, VisualEffectDef>,
    /// AI integration settings
    pub ai_integration: Option<AiIntegrationConfig>,
    /// Workspace configurations
    pub workspaces: HashMap<String, WorkspaceDef>,
    /// Theme definitions
    pub themes: HashMap<String, ThemeDef>,
    /// Semantic rules
    pub semantic_rules: Vec<SemanticRule>,
    /// Gesture configurations
    pub gestures: HashMap<String, GestureDef>,
}

/// Node type definition from Kotlin DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NodeTypeDef {
    pub display_name: String,
    pub description: String,
    pub category: String,
    pub icon: String,
    pub color: String,
    pub shape: String,
    pub size: String,
    pub visual: NodeVisualConfig,
    pub behavior: NodeBehaviorConfig,
    pub physics: Option<NodePhysicsConfig>,
}

/// Node visual configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NodeVisualConfig {
    pub use_actual_icon: Option<bool>,
    pub use_file_type_icon: Option<bool>,
    pub show_thumbnail: Option<bool>,
    pub show_profile_picture: Option<bool>,
    pub glow_on_activity: Option<bool>,
    pub scale_with_importance: Option<bool>,
    pub show_file_size: Option<bool>,
    pub show_presence_indicator: Option<bool>,
    pub glow_on_message: Option<bool>,
    pub show_completion_status: Option<bool>,
    pub show_due_date: Option<bool>,
    pub pulse_when_due: Option<bool>,
    pub animated_border: Option<bool>,
    pub glow_effect: Option<bool>,
}

/// Node behavior configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NodeBehaviorConfig {
    pub double_click_to_launch: Option<bool>,
    pub double_click_to_open: Option<bool>,
    pub double_click_to_message: Option<bool>,
    pub enable_context_menu: Option<bool>,
    pub connectable_as_source: Option<bool>,
    pub connectable_as_target: Option<bool>,
    pub drag_and_drop_enabled: Option<bool>,
    pub interactive_chat: Option<bool>,
    pub context_menu_items: Vec<String>,
}

/// Node physics configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NodePhysicsConfig {
    pub mass: f32,
    pub charge: f32,
    pub friction: f32,
    pub repulsion_strength: f32,
}

/// Edge type definition from Kotlin DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EdgeTypeDef {
    pub display_name: String,
    pub description: String,
    pub category: String,
    pub style: String,
    pub color: String,
    pub width: u32,
    pub animated: Option<bool>,
    pub show_arrow: Option<bool>,
    pub visual: Option<EdgeVisualConfig>,
}

/// Edge visual configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EdgeVisualConfig {
    pub flow_animation: Option<bool>,
    pub pulse_on_transfer: Option<bool>,
    pub color_by_data_type: Option<bool>,
    pub fade_with_age: Option<bool>,
    pub show_timestamp: Option<bool>,
    pub warning_glow: Option<bool>,
    pub shake_animation: Option<bool>,
}

/// Layout configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LayoutConfig {
    pub node_repulsion: Option<f32>,
    pub edge_attraction: Option<f32>,
    pub centering_force: Option<f32>,
    pub damping: Option<f32>,
    pub iterations: Option<u32>,
    pub level_separation: Option<u32>,
    pub node_separation: Option<u32>,
    pub direction: Option<String>,
    pub sort_method: Option<String>,
    pub radius: Option<u32>,
    pub start_angle: Option<f32>,
    pub sweep: Option<f32>,
    pub sort_by: Option<String>,
    pub constraints: Option<LayoutConstraints>,
}

/// Layout constraints
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LayoutConstraints {
    pub minimum_node_distance: f32,
    pub maximum_node_distance: f32,
    pub clustering_strength: f32,
}

/// Interaction definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct InteractionDef {
    pub enable_pan: Option<bool>,
    pub enable_zoom: Option<bool>,
    pub enable_rotate: Option<bool>,
    pub enable_selection: Option<bool>,
    pub enable_multi_select: Option<bool>,
    pub enable_box_select: Option<bool>,
    pub enable_pinch_zoom: Option<bool>,
    pub enable_two_finger_rotate: Option<bool>,
    pub enable_swipe_navigation: Option<bool>,
    pub enable_double_tap: Option<bool>,
    pub drag_behavior: Option<DragBehavior>,
    pub shortcuts: Option<HashMap<String, String>>,
    pub gesture_actions: Option<HashMap<String, String>>,
}

/// Drag behavior configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DragBehavior {
    pub enable_node_drag: bool,
    pub enable_edge_drag: bool,
    pub snap_to_grid: bool,
    pub grid_size: u32,
}

/// Visual effect definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VisualEffectDef {
    pub enabled: bool,
    pub intensity: Option<f32>,
    pub color: Option<String>,
    pub blur_radius: Option<u32>,
    pub animation_duration: Option<u32>,
    pub particle_count: Option<u32>,
    pub particle_size: Option<u32>,
    pub particle_speed: Option<f32>,
    pub particle_lifetime: Option<u32>,
    pub offset_x: Option<i32>,
    pub offset_y: Option<i32>,
}

/// AI integration configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AiIntegrationConfig {
    pub enabled: bool,
    pub provider: String,
    pub model: String,
    pub features: AiFeatures,
    pub analysis_rules: HashMap<String, AnalysisRule>,
}

/// AI features configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AiFeatures {
    pub enable_relationship_discovery: bool,
    pub enable_content_analysis: bool,
    pub enable_smart_clustering: bool,
    pub enable_workflow_prediction: bool,
    pub enable_semantic_search: bool,
}

/// AI analysis rule
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AnalysisRule {
    pub trigger: String,
    pub action: String,
    pub confidence: Option<f32>,
    pub interval: Option<String>,
}

/// Workspace definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WorkspaceDef {
    pub auto_cluster: bool,
    pub show_related_suggestions: Option<bool>,
    pub time_based_depth: Option<bool>,
    pub max_visible_nodes: Option<u32>,
    pub cluster_by: Option<Vec<String>>,
    pub default_layout: Option<String>,
    pub center_node: Option<String>,
    pub focus_mode: Option<FocusMode>,
    pub filters: Option<WorkspaceFilters>,
}

/// Focus mode configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FocusMode {
    pub enabled: bool,
    pub dim_background: bool,
    pub highlight_connected: bool,
}

/// Workspace filters
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WorkspaceFilters {
    pub show_only: Option<Vec<String>>,
    pub hide_older_than: Option<String>,
}

/// Theme definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ThemeDef {
    pub display_name: String,
    pub is_dark: bool,
    pub colors: ThemeColors,
    pub effects: Option<ThemeEffects>,
}

/// Theme colors
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ThemeColors {
    pub background: String,
    pub foreground: String,
    pub primary: String,
    pub secondary: String,
    pub accent: String,
    pub node_default: String,
    pub edge_default: String,
    pub selection: String,
}

/// Theme effects
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ThemeEffects {
    pub glow_intensity: f32,
    pub shadow_opacity: f32,
    pub animation_speed: f32,
}

/// Semantic rule
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SemanticRule {
    pub name: String,
    pub condition: String,
    pub action: String,
    pub strength: f32,
    pub decay: Option<String>,
}

/// Gesture definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GestureDef {
    pub fingers: u32,
    pub movement: String,
    pub action: String,
    pub sensitivity: Option<f32>,
    pub threshold: Option<u32>,
    pub duration: Option<u32>,
}

/// Services configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ServicesConfig {
    pub enabled: Vec<String>,
    pub systemd: HashMap<String, SystemdService>,
}

/// Systemd service definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SystemdService {
    pub description: String,
    pub wanted_by: Vec<String>,
    pub after: Vec<String>,
    pub service: ServiceConfig,
}

/// Service configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ServiceConfig {
    #[serde(rename = "type")]
    pub service_type: String,
    pub exec_start: String,
    pub restart: String,
    pub environment: HashMap<String, String>,
}

/// Packages configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PackagesConfig {
    pub groups: HashMap<String, PackageGroup>,
}

/// Package group
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PackageGroup {
    pub packages: Vec<String>,
}

/// Kotlin DSL configuration loader
pub struct KotlinDslLoader;

impl KotlinDslLoader {
    /// Load configuration from Kotlin DSL JSON output
    pub async fn load_from_json(path: &Path) -> Result<KotlinDslConfig> {
        let content = tokio::fs::read_to_string(path).await
            .context("Failed to read Kotlin DSL JSON file")?;
        
        let config: KotlinDslConfig = serde_json::from_str(&content)
            .context("Failed to parse Kotlin DSL JSON")?;
        
        Ok(config)
    }
    
    /// Convert Kotlin DSL config to graph desktop config
    pub fn convert_to_graph_config(
        kotlin_config: &KotlinDslConfig
    ) -> Result<crate::GraphDesktopConfig> {
        let mut config = crate::GraphDesktopConfig::default();
        
        // Apply graph desktop specific settings
        if let Some(graph_desktop) = &kotlin_config.graph_desktop {
            // General settings
            config.general.debug = graph_desktop.enable_voice_control; // Example mapping
            
            // Graph settings
            config.graph.physics_enabled = graph_desktop.enable_physics;
            config.graph.layout_algorithm = match graph_desktop.rendering_engine.as_str() {
                "WEBGPU" => "force-directed",
                _ => "force-directed",
            }.to_string();
            
            // Performance settings
            config.performance.max_nodes = graph_desktop.max_nodes as usize;
            
            // Interaction settings
            config.interaction.edge_creation_mode = crate::EdgeCreationMode::DragFromNode;
            
            // AI settings
            if let Some(ai) = &graph_desktop.ai_integration {
                config.ai.enabled = ai.enabled;
                config.ai.default_model = ai.model.clone();
            }
            
            // Apply themes
            if let Some(dark_theme) = graph_desktop.themes.get("dark") {
                if dark_theme.is_dark {
                    config.appearance.theme = "horizon-dark".to_string();
                }
            }
            
            // Store node types in custom config
            for (name, node_type) in &graph_desktop.node_types {
                let key = format!("node_type.{}", name);
                config.custom.insert(key, serde_json::to_value(node_type)?);
            }
            
            // Store edge types in custom config
            for (name, edge_type) in &graph_desktop.edge_types {
                let key = format!("edge_type.{}", name);
                config.custom.insert(key, serde_json::to_value(edge_type)?);
            }
            
            // Store layout configurations
            for (name, layout) in &graph_desktop.layouts {
                let key = format!("layout.{}", name);
                config.custom.insert(key, serde_json::to_value(layout)?);
            }
            
            // Process keyboard shortcuts
            if let Some(keyboard_interactions) = graph_desktop.interactions.get("KEYBOARD") {
                if let Some(shortcuts) = &keyboard_interactions.shortcuts {
                    for (key_combo, action) in shortcuts {
                        let shortcut = crate::KeyboardShortcut {
                            keys: key_combo.clone(),
                            action: action.to_lowercase().replace(" ", "_"),
                            description: action.clone(),
                        };
                        config.shortcuts.insert(
                            action.to_lowercase().replace(" ", "_"),
                            shortcut
                        );
                    }
                }
            }
        }
        
        Ok(config)
    }
    
    /// Load and convert configuration in one step
    pub async fn load_and_convert(path: &Path) -> Result<crate::GraphDesktopConfig> {
        let kotlin_config = Self::load_from_json(path).await?;
        Self::convert_to_graph_config(&kotlin_config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_kotlin_dsl_loader() {
        // Test with a sample JSON structure
        let sample_json = r#"{
            "system": {
                "hostname": "horizonos-graph",
                "timezone": "America/New_York",
                "locale": "en_US.UTF-8"
            },
            "graphDesktop": {
                "enabled": true,
                "renderingEngine": "WEBGPU",
                "enablePhysics": true,
                "enableGestures": true,
                "enableKeyboardNavigation": true,
                "enableVoiceControl": false,
                "maxNodes": 10000,
                "maxEdges": 50000,
                "performanceMode": "BALANCED",
                "nodeTypes": {},
                "edgeTypes": {},
                "layouts": {},
                "interactions": {},
                "visualEffects": {},
                "workspaces": {},
                "themes": {},
                "semanticRules": [],
                "gestures": {}
            }
        }"#;
        
        // Write to temp file
        let temp_dir = tempfile::tempdir().unwrap();
        let config_path = temp_dir.path().join("config.json");
        tokio::fs::write(&config_path, sample_json).await.unwrap();
        
        // Test loading
        let kotlin_config = KotlinDslLoader::load_from_json(&config_path).await.unwrap();
        assert!(kotlin_config.graph_desktop.is_some());
        
        // Test conversion
        let graph_config = KotlinDslLoader::convert_to_graph_config(&kotlin_config).unwrap();
        assert!(graph_config.graph.physics_enabled);
        assert_eq!(graph_config.performance.max_nodes, 10000);
    }
}